# Scaffold 까보기

```Ruby
# new.html.erb
<h1>New Post</h1>
#  render 보여주라는 의미 rendering 
# post에 @post를 넣었다.
<%= render 'form', post: @post %>

<%= link_to 'Back', posts_path %>
```
```Ruby
# edit.html.erb
<h1>Editing Post</h1>

<%= render 'form', post: @post %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
```


- form.html.erb파일
```Ruby
# _form.html.erb 파일
# form 태그와 비슷하다는 것을 알 수 있다.
<%= form_for(post) do |f| %>
    <div class="field">
        <%= f.label :title %>
        <%= f.text_field :title %>'
    </div>

    <div class="field">
        <%= f.label :content %>
        <%= f.text_area :content %>
    </div>

    <div class="actions">
        <%= f.submit %>
    </div>
<% end %>
```
- 위 내용이 render라고 쓴 부분에 그대로 삽입이 된다고 생각하면된다.
- render를 통해서 파일을 끼워넣고 싶을때는 form이라는 뷰파일 앞에 언더바`_`가 있어야 한다. `<%= render 'form', post: @post %>`
- `post:@post`부분은 앞으로는 @post를 그냥 post라고 부르겠다는 것.

form이라는 파일을 찾아보면 _form.html.erb파일을 알 수가 있는데요. 이 form.html.erb 안의 내용이 render라고 쓴 부분에 그대로 써진다고 생각하시면 됩니다. 그런데 여태 우리가 배운 바에 의하면, new는 새 글이 써지는 페이지니까 상관없지만 edit는 이전에 썼던 내용이 자동으로 불러와져야 하는데 같은 form을 쓰는게 이해가 안될 겁니다. 그리고 form_for에는 별도의 url도 보이지 않죠.

그런데 이 form_for라는 레일즈에서 제공하는 폼 헬퍼는 post가 새 게시물인지 혹은 이전에 한 번 썼던 게시물인지를 자동으로 판별하여 새로운 게시물인 경우에는 create 액션으로 보내주고. 이미 만들어졌던 게시물인 경우 update 액션으로 보내준다. <br>
마찬가지로 이전에 썼던 게시물인 경우 그 value로 이전 내용을 자동으로 불러와준다. 그래서 저번시간에는 썼지 않았지만, scaffold의 new 액션에서는 @post = Post.new라는 말이 꼭 들어가야 한다. 그래야 Post.new 상태의 아직 빈 게시물이고 여기에 내용과 제목을 넣어 새 게시물을 생성하겠다!라는 뜻으로 받아들여진다.


## form_for
### 모델 객체(post)가 `신규` or `이미 저장 완료`됐는지를 판단해 적절한 url로 안내해준다.

### 즉,form_for는 자동으로 판단해서, @post = Post.new면 create action으로, @post = Post.find(params[:id])면 update 액션으로 보내준다.

하지만 posts_controller.rb파일의 코드를 보면 @post에 관한 코드가 없어 어리둥절하다. 

답은 두번째 줄에 
```before_action :set_post, only: %i[ show edit update destroy ]``` 에 있다. 
사전에 show, eidt, update, destroy 에 대해서는 set_post 작업을 하도록 되어 있다. <br>
모두 한 특정 게시물에 관한 사항이므로, set_post는 한 게시물에 관한 사항이다.
<br> 각각의 액션에 set_post 작업이 들어가 있는 것이다.